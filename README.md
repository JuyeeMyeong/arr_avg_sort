## 1번 과제 - 간단한 프로그래밍 구현

사용자로부터 **N (5)**개의 정수 입력을 받아 배열에 저장한 뒤,

1. 요소들의 **총합과 평균**을 구한다.  
2. 배열을 **오름차순과 내림차순**으로 정렬하는 프로그램을 구현한다.

---

## 왜 선택 정렬과 삽입 정렬이 사용되었을까?

정렬될 배열의 크기가 작을 때 (요소 10개 이하),  
**선택 정렬과 삽입 정렬은 구현 시간도 간단**하며 이론적으로는 `O(n²)`의 복잡도를 가지지만,  
**추가 메모리를 쓰지 않고 정렬이 가능**하기 때문에 간단한 과제 수준에서 적절한 알고리즘이다.

---

### 정렬 알고리즘 비교

| 알고리즘     | 평균 시간 복잡도 | 최악 시간 복잡도 | 추가 메모리 | 설명 |
|--------------|------------------|------------------|--------------|-------|
| **삽입 정렬** | O(n²)             | O(n²)             | O(1)         | 앞에서 미리 순서를 결정하고 확인하기 때문에 거의 정렬된 상태가 맞다면 Best Case는 `O(n)`의 복잡도를 가질 수 있다. |
| **선택 정렬** | O(n²)             | O(n²)             | O(1)         | 항상 배열을 돌아봐야 하기 때문에 효율은 조금 낮다. |
| **퀵 정렬**   | O(n log n)        | O(n²)             | O(log n)     | 분할 시 값이 한쪽으로 치우쳐져 있으면 삽입 정렬보다 비효율적일 수 있다. *(메모리적으로)* |
| **병합 정렬** | O(n log n)        | O(n log n)        | O(n)         | 추가 메모리 사용이 가장 비효율적이다. |
| **힙 정렬**   | O(n log n)        | O(n log n)        | O(1)         | 추가 메모리는 사용하지 않는다. 최소/최댓값을 빠르게 찾는 데 주로 이용되며 정렬 자체에는 복잡하다. |

---

